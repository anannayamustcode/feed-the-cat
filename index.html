<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    <script src="https://unpkg.com/ml5@0.20.0-alpha.3/dist/ml5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <meta charset="utf-8" />
    <style>
      html, body {
        margin: 0;
        padding: 0;
        background-color: #539bc5;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <main></main>
    <script>
      // Based on: 
      // ml5.js handpose demo: 
      // https://editor.p5js.org/ml5/sketches/QGH3dwJ1A
      // Matter.js bridge demo: 
      // https://editor.p5js.org/natureofcode/sketches/7U7yrrbNz

      const THUMB_TIP = 4; 
      const INDEX_FINGER_TIP = 8; 

      // Game variables
      let score = 0;
      let startTime;
      let gameTime = 60; // 60 seconds game duration
      let isGameActive = false;

      // Cat image
      let catImg;
      let bgColor;

      // Cat mouth position - adjusted for full screen cat
      const CAT_MOUTH = {
        x: 520,  // adjusted for full screen
        y: 400,  // adjusted for full screen
        radius: 40 // detection radius for the mouth
      };

      // Matter.js physics stuff
      const { Engine, Bodies, Composite, Constraint, Body, Vector } = Matter;
      let engine;
      let bridge;
      let particles = [];

      // ml5.js tracker stuff
      let handpose;
      let video;
      let hands = [];
      let handOptions = { maxHands: 1, flipHorizontal: true };

      function preload() {
        // Load the handpose model.
        handpose = ml5.handpose(handOptions);
        // Load cat image
        catImg = loadImage('cat.png');
      }
      
      function gotHands(results) {
        // Callback function; save the output to the hands variable
        hands = results;
      }

      function setup() {
        createCanvas(640, 480);
        engine = Engine.create();
        bridge = new Bridge(16);
        
        // Set background color - CHANGE THIS LINE to customize!
        // Option 1: Use a specific color name
        bgColor = color('lightblue');
        
        // Option 2: Use RGB values (uncomment to use)
        // bgColor = color(255, 200, 150); // peachy color
        
        // Option 3: Use hex color (uncomment to use)
        // bgColor = color('#f5e6d3'); // beige
        
        // Option 4: Sample from cat image (uncomment to use)
        // catImg.loadPixels();
        // let sampleX = floor(catImg.width * 0.3);
        // let sampleY = floor(catImg.height * 0.3);
        // let index = (sampleY * catImg.width + sampleX) * 4;
        // bgColor = color(catImg.pixels[index], catImg.pixels[index + 1], catImg.pixels[index + 2]);
        
        // Create the webcam, start detecting hands
        video = createCapture(VIDEO);
        video.size(width, height);
        video.hide();
        handpose.detectStart(video, gotHands);
        
        // Start the game
        startTime = millis();
        isGameActive = true;
      }


      function draw() {
        // Use cat's background color
        background(bgColor);
        
        // Draw cat image full screen
        image(catImg, 0, 0, width, height);
        
        // Draw webcam feed with transparency overlay
        push();
        if (handOptions.flipHorizontal){
          translate(width,0);scale(-1,1);
        }
        tint(255,255,255,60); 
        image(video, 0, 0, width, height);
        pop();
        
        renderTrackedHandPoints(); // if you want
        
        if (hands.length > 0){
          noFill();
          stroke("red");
          let thumbx = hands[0].keypoints[THUMB_TIP].x;
          let thumby = hands[0].keypoints[THUMB_TIP].y;
          let indexx = hands[0].keypoints[INDEX_FINGER_TIP].x;
          let indexy = hands[0].keypoints[INDEX_FINGER_TIP].y;
          circle (thumbx,thumby, 30);
          circle (indexx,indexy, 30);
        }
        
        if (isGameActive) {
          occasionallyMakeNewBalls(); 
          Engine.update(engine);
          bridge.setToHandPoints();
          bridge.show();
          renderBalls(); 
          checkBallsInMouth();
          removeOutOfBoundsBalls(); 
        }
        
        // Display score and timer
        displayUI();
        
        // Check if game is over
        checkGameOver();
      }

      function displayUI() {
        // Display score
        fill(0);
        stroke(255);
        strokeWeight(3);
        textSize(32);
        textAlign(LEFT, TOP);
        text(`Score: ${score}`, 20, 20);
        
        // Display timer
        let elapsed = floor((millis() - startTime) / 1000);
        let remaining = max(0, gameTime - elapsed);
        textAlign(RIGHT, TOP);
        
        if (remaining <= 10) {
          fill(255, 0, 0); // Red when time is running out
        }
        text(`Time: ${remaining}s`, width - 20, 20);
        
        // Draw cat mouth indicator (green circle shows detection area)
        noFill();
        stroke(0, 255, 0);
        strokeWeight(2);
        circle(CAT_MOUTH.x, CAT_MOUTH.y, CAT_MOUTH.radius * 2);
      }

      function checkGameOver() {
        let elapsed = floor((millis() - startTime) / 1000);
        if (elapsed >= gameTime && isGameActive) {
          isGameActive = false;
          displayGameOver();
        }
      }

      function displayGameOver() {
        fill(0, 0, 0, 200);
        rect(0, 0, width, height);
        
        fill(255);
        textSize(48);
        textAlign(CENTER, CENTER);
        text("Game Over!", width / 2, height / 2 - 50);
        
        textSize(32);
        text(`Final Score: ${score}`, width / 2, height / 2 + 20);
        
        textSize(20);
        text("Refresh to play again", width / 2, height / 2 + 70);
      }

      function checkBallsInMouth() {
        // Check if any balls are in the cat's mouth
        for (let i = particles.length - 1; i >= 0; i--) {
          let pos = particles[i].body.position;
          let d = dist(pos.x, pos.y, CAT_MOUTH.x, CAT_MOUTH.y);
          
          if (d < CAT_MOUTH.radius) {
            // Ball is in the mouth!
            score++;
            particles[i].removeBody();
            particles.splice(i, 1);
          }
        }
      }

      //---------------------------------------------------------
      function renderTrackedHandPoints(){
        // Draw all the tracked hand points
        for (let i = 0; i < hands.length; i++) {
          let hand = hands[i];
          for (let j = 0; j < hand.keypoints.length; j++) {
            let keypoint = hand.keypoints[j];
            fill('red');
            noStroke();
            circle(keypoint.x, keypoint.y, 5);
          }
        }
      }

      //---------------------------------------------------------
      function occasionallyMakeNewBalls(){
        if (random(1) < 0.05) {
          particles.push(new Particle(width / 2 + random(-60, 60), 0));
        }
      }

      function renderBalls(){
        // render the balls
        for (let i = 0; i< particles.length; i++) {
          particles[i].show();
        }
      }

      function removeOutOfBoundsBalls(){
        // Remove out-of-bounds balls, from the world and the array
        for (let i = particles.length - 1; i >= 0; i--) {
          if (particles[i].checkEdge()) {
            particles[i].removeBody();
            particles.splice(i, 1);
          }
        }
      }


      //---------------------------------------------------------
      class Bridge {
        // From https://editor.p5js.org/natureofcode/sketches/7U7yrrbNz
        constructor(len) {
          this.r = len / 2;
          this.len = len;
          this.particles = [];
          this.constraints = [];
          for (let i = 0; i < len; i++) {
            let px = map(i,0,len-1, 220,420);
            let py = height * 0.75;
            let particle = Bodies.circle(px, py, this.r, { restitution: 0.7 });
            this.particles.push(particle);
            Composite.add(engine.world, particle);
          }
          this.particles[0].isStatic = true;
          this.particles[this.particles.length - 1].isStatic = true;

          
          for (let i = 0; i < this.particles.length - 1; i++) {
            let options = {
              bodyA: this.particles[i],
              bodyB: this.particles[i + 1],
              length: len,
              stiffness: 1,
            };
            let constraint = Matter.Constraint.create(options);
            Composite.add(engine.world, constraint);
          }
        }
        
        setToHandPoints(){
          if (hands.length > 0){
            let thumbx = hands[0].keypoints[THUMB_TIP].x;
            let thumby = hands[0].keypoints[THUMB_TIP].y;
            let indexx = hands[0].keypoints[INDEX_FINGER_TIP].x;
            let indexy = hands[0].keypoints[INDEX_FINGER_TIP].y;

            let index0 = 0; 
            let index1 = this.particles.length - 1;
            Body.setPosition(this.particles[index0], {x:thumbx, y:thumby }); 
            Body.setPosition(this.particles[index1], {x:indexx, y:indexy }); 
          }
        }

        show() {
          fill(80);
          stroke(0);
          for (let particle of this.particles) {
            push();
            translate(particle.position.x, particle.position.y);
            circle(0, 0, this.r * 2);
            pop();
          }
        }
      }

      //---------------------------------------------------------
      class Particle {
        constructor(x, y) {
          this.r = 8;
          let options = {
            restitution: 0.6,
            collisionFilter: {
              category: 0x0002,
            },
          };
          this.body = Bodies.circle(x, y, this.r, options);
          Composite.add(engine.world, this.body);
        }

        show() {
          let pos = this.body.position;
          let a = this.body.angle;
          fill(180);
          stroke(0);
          strokeWeight(2);
          push();
          translate(pos.x, pos.y);
          rotate(a);
          circle(0, 0, this.r * 2);
          line(0, 0, this.r, 0);
          pop();
        }

        checkEdge() {
          return this.body.position.y > height + this.r;
        }
        removeBody() {
          Composite.remove(engine.world, this.body);
        }
      }
    </script>
  </body>
</html>